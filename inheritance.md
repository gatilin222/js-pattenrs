# ШАБЛОНЫ НАСЛЕДОВАНИЯ

## Магическая функция inherit

```javascript
// родительский конструктор
function Parent(name) {
	this.name = name || 'Adam';
}

// добавление дополнительной функциональности в прототип
Parent.prototype.say = function() {
	return this.name;
};

// Пустой дочерний конструктор
function Child() {}

// Здесь происходит магия наследования
inherit(Child, Parent);
```

## Классический шаблон №1: Шаблон по умолчанию

Создаем новый объект с помощью конструктора Parent() и присваиваем его свойству prototype конструктора Child

```javascript
function inherit(C, P) {
	C.prototype = new P();
}
```

Важно: свойство prototype ссылается на объект, а не на функцию
При таком шаблоне экземпляры наследуют не только собственные свойства (name например),
но и свойства и методы прототипа(say например)
Но в данном случае можно изменить свойство name для экземпляра Child вот так:

```javascript
var kid = new Child();
kid.name = 'Patrik';
kid.say(); // 'Patrik'
```

Недостатки шаблона №1:
Экземпляры класса наследуют не только свойства прототипа родительского прототипа,
но и собственные свойства(такие как name).

Другой недостаток - передача параметров при вызове дочернего конструктора не работает
Пример:

```javascript
var s = new Child('Smith');
s.say(); // "Adam"
```

Можно организовать передачу параметров внутри дочернего конструктора к родительскому, но это не эффективно, так как все время при вызове new Child, будет создаваться экземпляр родительского конструктора.

## Классический шаблон №2: Заимствование конструктора

В этом шаблоне передаются аргументы дочернего конструктора в родительский:

```javascript
function Child(a, c, b, d) {
	Parent.apply(this, arguments);
}
```

При таком подходе наследуются только свойства, добавленные внутри родительского конструктора,
свойства прототипа не наследуются. При таком наследовании экземпляры получают копии наследуемых свойств, в отличие от классического шаблона, где они получают ссылки.
Отличия демонстрируются в следующем примере:

```javascript
function Article() {
	this.tags = ['js','css'];
}

var article = new Article();

// Классический шаблон
function BlogPost(){};
BlogPost.prototype = article;
var blogPost = new BlogPost();

// Шаблон заимствования конструктора
function StaticPage() {
	Article.call(this);
}
var staticPage = new StaticPage();

blogPost.hasOwnProperty('tags'); // false
article.hasOwnProperty('tags'); // true
staticPage.hasOwnProperty('tags'); // true
```

Следует обратить внимание, что если попробовать изменить свойство tags у потомков, 
оно изменится и у родительского объекта, потому что оба их свойства ссылаются на один
и тот же массив.

```javascript
blogPost.tags.push('html');
staticPage.tags.push('php');

article.tags.join(', '); // "js, css, html"
```

При таком способе мы можем осуществить множественное наследование:

```javascript
function Cat() {
	this.legs = 4;
	this.say = function() {
		console.log('meaaawu');
	}
}

function Bird() {
	this.wings = 2;
	this.fly = function() {
		console.log("Ok, I'am flying");
	}
}

function CatBird() {
	Cat.apply(this);
	Bird.apply(this);
}

var monstr = new CatBird();
```

Достоинства и недостатки шаблона заимствования конструктора:

Недостаток очевиден - свойства прототипа не копируются. Преимущество заключается в том, что объекты, создаваемые дочерним конструктором получают собственные свойства, а не ссылки на родительские.

## Классический шаблон №3: Заимствование и установка прототипа

Идея шаблона в том, чтобы сначала заимствовать конструктор, а затем сохранить в 
свойстве prototype дочернего объекта ссылку на новый экземпляр родительского конструктора:

```javascript
function Child(a, c, b, d) {
	Parent.apply(this, arguments);
}
Child.prototype = new Parent();
```

В этом шаблоне дочерний объект получает собственные копии собственных членов родительского объекта,
при этом их можно изменять, не боясь за родительские объекты.
Недостаток заключается в том, что Parent вызывается дважды, что снижает эффективность,
и свойства дублируются(они есть и у дочернего объекта, и у его прототипа).
Рассмотрим пример, выполняющий тестирование этого шаблона:

```javascript

function Parent(name) {
	this.name = name || 'Adam';
}

Parent.prototype.say = function() {
	return this.name;
};

function Child(name) {
	Parent.apply(this, arguments);
}
Child.prototype = new Parent();

var kid = new Child('Patrik');
kid.name; // 'Patrik'
kid.say(); // 'Patrik'
delete kid.name;
kid.say(); // 'Adam'
```

Так как свойство name было унаследовано дважды, при удалении его из объекта kid,
оно наследуется от прототипа.

## Классический шаблон №4: Совместное использование прототипа

В отличие от предыдущего способа, где родительский конструктор вызывался дважды, в этом способе он  вообще не вызывается. При таком способе наследования доступ к повторно используемым членам обеспечивается прототипом, а не ссылкой this. Мы просто присваиваем родительский прототип дочернему прототипу.

```javascript
function inherit(C, P) {
	C.prototype = P.prototype;
}
```

В этом случае родительский и дочерний конструктор используют один и тот же прототип, это опасно, так как если дочерний объект изменит прототип, это скажется и на родительских объектах.

## Классический шаблон №5: Временный конструктор

В этом шаблоне разрывается связь между родительским и дочерним прототипами, функция F - 
передаточное звено.

```javascript
function inherit(C, P) {
	var F = function() {};
	F.prototype = P.prototype;
	C.prototype = new F();
}
```

Здесь потомок наследует только свойства прототипа. Обычно это наиболее предпочтительное поведение, т.к.
потому что прототип является местом сосредоточения повторно используемой функциональности. В этом шаблоне все свойства, добавляемые родительским конструктором не наследуются экземплярами дочернего конструктора.
Создадим новый дочерний объект и исследуем особенности его поведения:

```javascript
var kid = new Child();
```

kid.name выведет undefined, так как в этом шаблоне наследуются только свойства прототипа.
kid.say() существует, но выведет undefined. Если явно присвоить имя, то метод say вернет его:

```javascript
kid.name = 'Alex';
kid.say(); // 'Alex'
```

## Сохранение суперкласса

Шаблон временного конструктора можно расширить, добавив ему ссылку на оригинального предка.
Это напоминает доступ к суперклассу в других языках и может оказаться полезным
в некоторых ситуациях. Назовем свойство 'uber', потому что слово super является зарезервированным,
а superclass будет навеивать на мысль, что в JS есть классы(на самом деле есть в ES2015)

```javascript
function inherit(C, P) {
	var F = function() {};
	F.prototype = P.prototype;
	C.prototype = new F();
	C.uber = P.prototype;
}
```

